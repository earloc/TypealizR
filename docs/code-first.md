
# TypealizR - code-first

The `code-first` approach let¬¥s you specify ordinary, **strongly typed** `Interfaces` (a.k.a `typealized interfaces`) to let you just utilize familiar code artefacts when dealing with i18n.
These `typealized interfaces` then get picked up by the `source-generator`, which generates an implementing class that then can be used f.e. in conjuntion with ordinary `dependency-injection`.
This way, devlepors do not need to leave their natural habitat (the code-editor), which comes with the benefit of automatic code-refactorings, ultimatley optimizing the [inner-loop](https://notes.serverlessfirst.com/public/The+inner+and+outer+loops+of+software+development+workflow#Inner+loop), even during i18n-tasks.

![GenerateMethod](../assets/demo_TypealizedInterface_GenerateMethod.gif)

## pre-requisits
The consuming target project should at least reference a suitable version of [Microsoft.Extensions.Localization.Abstractions](https://www.nuget.org/packages/Microsoft.Extensions.Localization.Abstractions)

## getting started

- install [TypealizR](https://www.nuget.org/packages/TypealizR)  via [![NuGet](https://img.shields.io/nuget/v/TypealizR)](https://www.nuget.org/packages/TypealizR)
- install [TypealizR.CodeFirst.Abstractions](https://www.nuget.org/packages/TypealizR.CodeFirst.Abstractions) via [![NuGet](https://img.shields.io/nuget/v/TypealizR.CodeFirst.Abstractions)](https://www.nuget.org/packages/TypealizR.CodeFirst.Abstractions)
- Author a `Typealized-Interface` which basically is just an ordinary `interface`, marked with `CodeFirstTypealizedAttribute` somewhere within your project.
  
  ![demo_TypealizedInterface](../assets/demo_TypealizedInterface.png)
  ```csharp
    using TypealizR.CodeFirst.Abstractions;
    namespace Sample;

    [CodeFirstTypealized] // <-- this marks the interface as `to-be-typealized`
    public interface ILocalizables
    {
    }
  ```
  - Use properties for plain `translatables`.
    ```csharp
    using TypealizR.CodeFirst.Abstractions;
    namespace Sample;

    [CodeFirstTypealized]
    public interface ILocalizables
    {
        LocalizedString Hello { get; } // <-- simple translatables
    }
    ```
    > return-type needs to be `LocalizedString`
    > the generated code uses the property name `Hello` as the default-value

  - Use methods for type-safe translation of formatted `translatables`.
    ```csharp
    using TypealizR.CodeFirst.Abstractions;
    namespace Sample;

    [CodeFirstTypealized] 
    public interface ILocalizables
    {
        LocalizedString Greet(string userName, string planetName); // <-- formatted translatables
    }
    ```
    > return-type needs to be `LocalizedString`
    > the generated code uses the method name `Greet` as the default-value

  - setup dependency-injection in your startup-code
    ```csharp
    var services = new ServiceCollection();
    services.AddLogging(); //<-- required by `Microsoft.Extensions.Localization`
    services.AddLocalization(); //<-- required by `Microsoft.Extensions.Localization`
    services.AddSingleton<ILocalizables, Localizables>(); // <-- `Localizables` gets generated by TypealizR
    var provider = services.BuildServiceProvider();
    ```

  - start using the generated implementation
    ```csharp
    var codeFirst = provider.GetRequiredService<IStrings>();
    Console.WriteLine(codeFirst.Hello); // Hello
    Console.WriteLine(codeFirst.Greet("Arthur", "üåç earth")); // Greet Arthur üåç earth
    ```
  - Utilize [structured xml comments](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/xmldoc/) to provide custom default-values
    ```csharp
    using Microsoft.Extensions.Localization;
    using TypealizR.CodeFirst.Abstractions;

    namespace ConsoleSTS.CodeFirst;

    [CodeFirstTypealized]
    public interface ILocalizables
    {
        /// <summary>
        /// Hello, fellow developer!
        /// </summary>
        public LocalizedString Hello { get; }

        /// <summary>
        /// Hey <paramref name="userName"/>, welcome to <paramref name="planetName"/> üëç!
        /// </summary>
        public LocalizedString Greet(string userName, string planetName);
    }

    ```
    ```csharp
    var codeFirst = provider.GetRequiredService<IStrings>();
    Console.WriteLine(codeFirst.Hello); // Hello, fellow developer!
    Console.WriteLine(codeFirst.Greet("Arthur", "üåç earth")); // Hey Arthur, welcome to üåç earth üëç!
    ```

## generate resources
- install [TypealizR.CLI](https://www.nuget.org/packages/TypealizR.CLI) (as local or global tool) via [![NuGet](https://img.shields.io/nuget/v/TypealizR.CLI)](https://www.nuget.org/packages/TypealizR.CLI)
- run it on your project
  - `dotnet tr code-first export some/path/to/a.csproj`, or alternatively
    > `dotnet tr cf ex some/path/to/a.csproj`

  This will extract the following `resx`-file for above sample:
  ![TypealizedInterface_Resx](../assets//demo_TypealizedInterface_Resx.png?raw=true)
  ```xml
    <data name="Hello">
      <value>Hello, fellow developer!</value>
    </data>
    <data name="Greet">
      <value>Hey {0}, welcome to {1} üëç!</value>
    </data>
  ```
  > executing this will OVERWRITE any existing file at the moment. In the future, TypealizR will be aware of existing files and provide a way to synchronize code with those files, in order to not loose any customizations done within them. Follow [the discussion](https://github.com/earloc/TypealizR/discussions/78) and let¬¥s define together, what workflows would be needed to make code-first-i18n a real game-changer in the future!